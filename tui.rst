=====================
Text user's interface
=====================

The text user's interface to DW can be used with any interactive python
interpreter.

The following preliminary steps are required to start working with DW in
text mode.

Preliminary steps
=================

Importing the module
~~~~~~~~~~~~~~~~~~~~
::

    import dw.core.data_def as dw

Instatiating a DW class
~~~~~~~~~~~~~~~~~~~~~~~
::

    dwc = dw.DWData()

Opening and closing data
========================

Opening a data file
~~~~~~~~~~~~~~~~~~~
::

    dwc.open_data(filename, [filetype])

*filename* is a string containing the path to the opening file.
*filetype* is a string denoting the fileype. Current available filetypes are:

* *fits*: single dish FITS data format in use at the Italian radio telescopes
* *hdf*: DW data format in a HDF5 container
* *hdf_pola*: DW polarimeter format in a HDF5 container (experimental)

Closing a data file
~~~~~~~~~~~~~~~~~~~
::

    dwc.close()

Retrieving data and metadata
============================


Read a data table
~~~~~~~~~~~~~~~~~
::

    m = dwc.dataset2np_array(i_dataset)
    

*i_dataset* is the index of the corrensponding dataset

*m* is an array of 2D numpy arrays which are the data of L and R polarizations

Read a polarimeter data table
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::

    m = dwc.polaset2np_array(i_dataset)
    

*i_dataset* is the index of the corrensponding dataset

*m* is an array of 2D numpy arrays which are the data of the stokes parameters (L, R, Q, U, I, V, Phi, P)

Retrieve data time scale
~~~~~~~~~~~~~~~~~~~~~~~~
::

    t = dwc.get_time_scale(i_dataset)
    

*i_dataset* is the index of the corrensponding dataset

*t* is a 1D numpy array containing the time values of the selected dataset samples

Retrieve data time scale in UT format
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::

    t = dwc.get_ut(i_dataset)
    

*i_dataset* is the index of the corrensponding dataset

*t* is a 1D numpy array containing the time values in UT format of the selected dataset samples

Retrieve data frequencies scale
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::

    f = dwc.get_freq_scale(i_dataset)
    

*i_dataset* is the index of the corrensponding dataset

*f* is a 1D numpy array containing the frequency values of the selected dataset samples

Retrieve data bandwidth
~~~~~~~~~~~~~~~~~~~~~~~
::

    b = dwc.get_bandwidth(i_dataset)
    

*i_dataset* is the index of the corrensponding dataset

*b* is the dataset bandwidth

Retrieve data ascension
~~~~~~~~~~~~~~~~~~~~~~~
::

    a = dwc.get_ascension(i_dataset)
    

*i_dataset* is the index of the corrensponding dataset

*a* is a 1D numpy array containing the 'per sample' dataset right ascension

Retrieve data azimuth
~~~~~~~~~~~~~~~~~~~~~
::

    a = dwc.get_azimuth(i_dataset)
    

*i_dataset* is the index of the corrensponding dataset

*a* is a 1D numpy array containing the 'per sample' dataset azimuth

Retrieve data declination
~~~~~~~~~~~~~~~~~~~~~~~~~
::

    d = dwc.get_declination(i_dataset)
    

*i_dataset* is the index of the corrensponding dataset

*d* is a 1D numpy array containing the 'per sample' dataset declination

Retrieve data elevation
~~~~~~~~~~~~~~~~~~~~~~~
::

    e = dwc.get_elevation(i_dataset)
    

*i_dataset* is the index of the corrensponding dataset

*e* is a 1D numpy array containing the 'per sample' dataset elevation

Retrieve pointed source name
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::

    s = dwc.get_source(i_dataset)
    

*i_dataset* is the index of the corrensponding dataset

*s* is a 1D numpy array containing the 'per sample' pointed source name

Retrieve the 'on track' flag
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::

    t = dwc.get_on_track(i_dataset)
    

*i_dataset* is the index of the corrensponding dataset

*t* is a 1D numpy array containing the 'per sample' flag stating whether the source is on track (1 = pointing error < 0.1*HPBW) or not (0 = pointing error > 0.1*HPBW)


Correcting data
===============

Open a correction file
~~~~~~~~~~~~~~~~~~~~~~
::

    dwc.open_correction(file_name)


*file_name* is a correction file generated by BPC (see :doc:`bpc`)

Toggle corrections on data
~~~~~~~~~~~~~~~~~~~~~~~~~~
::

    dwc.toggle_correction()


This will switch the correction on (or off) while reading data from datasets.
To check if the correction is active see the boolean value of:

::

    dwc.correction


Flagging data
=============

Create a new flagging set by rectangular area list
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:: 

    dwc.new_flagset(i_dataset, flag_areas)
    
*i_dataset* is the index of the corrensponding dataset

*flag_areas* is a list of areas to set as flagged (ymin, ymax, xmin, xmax)    

.. Update flagging set by rectangular area list
.. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. ::

..     dwc.upd_flagset(i_dataset, k_flagset, flag_areas, flag_value = prefs.FLAG_TRUE)

.. *i_dataset* is the index of the corrensponding dataset

.. *k_flagset* is the key of the flagset in the flagsets dictionary

.. *flag_areas* is a list of areas to set as flagged (ymin, ymax, xmin, xmax)    

.. *flag_value* is the value to be set in the selected areas (the default behaviour is to set the areas as flagged)


.. Deflag a flagging set by rectangular area list
.. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. ::

..     dwc.deflag_flagset(i_dataset, k_flagset, flag_areas)

.. *i_dataset* is the index of the corrensponding dataset

.. *k_flagset* is the key of the flagset in the flagsets dictionary

.. *flag_areas* is a list of areas to set as flagged (ymin, ymax, xmin, xmax)    

.. This method actually use the previous one with *flag_value = FLAG_FALSE*


Create a new flagging set from a list of arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::

    dwc.array_flagset(i_dataset, flag_arrays)
    
*i_dataset* is the index of the corrensponding dataset

*flag_arrays* is a list of numpy arrays (same shape as data) representing the flagging sets


Retrieve the list of the flagging sets belonging to the selected dataset
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::

    dwc.get_flagsets(i_dataset)
    
*i_dataset* is the index of the corrensponding dataset


Read flag data table
~~~~~~~~~~~~~~~~~~~~
::

   f = flagset2np_array(i_dataset, k_flagset)

*i_dataset* is the index of the corrensponding dataset
*k_flagset* is the key of the flagset in the flagsets dictionary

*f* is a 2D numpy array of the dimensions of the data which rappresent the matrix of the *k_flagset* of the *i_dataset* dataset

To obtain a dictionary of all the flasgsets of a given dataset

::

   d = flagsets2np_array(i_dataset)


Merge flagging sets
~~~~~~~~~~~~~~~~~~~
::

    dwc.merge_flagsets(i_dataset, k_flagsets)

*i_dataset* is the index of the corrensponding dataset

*k_flagsets* is a list of keys of flagsets to merge


Delete flagging sets
~~~~~~~~~~~~~~~~~~~~
::

    dwc.del_flagset(i_dataset, k_flagset):

*i_dataset* is the index of the corrensponding dataset

*k_flagset* is the key of the flagset in the flagsets dictionary


Delete flagging sets intersecating a rectangular area
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::

   dwc.del_sel_flag(i_dataset, rect_area)

*i_dataset* is the index of the corrensponding dataset

*rect_area* is a tuple rappresenting a rectangular area: (y_min, y_max, x_min, x_max)

Every flag area intersected by *rect_area* will be removed

Retrieve metadata related to the selected flagging set
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::

    md = dwc.get_flagset_meta(i_dataset, k_flagset)

*i_dataset* is the index of the corrensponding dataset

*k_flagset* is the key of the flagset in the flagsets dictionary

*md* is a dictionary containing the metadata

Copy the flag table to others files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::

   dwc.propag_flagtable(filelist)

*filelist* is a list of file paths where the entries of the current flag table will be copied

Automatic flagging
==================

Automatic flagging requires a minimum of two steps to be performed:

- flagging algorithm selection and initialization
- flagging computation

Optionally the user can:

- select algorithm's parameters
- select the algorithm's output (among the algorithm's available selection)

Algorithm selection and initialization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    dwc.auto_flag_init(i_dataset, alg)
    
*i_dataset* is the index of the corrensponding dataset

*alg* is the RFI detection algorithm class.

The available algorthms can be listed using

::

    dwc.get_rfi_dect_algorithms()

This method returns a dictionary whose keys are the RFI detection algorithm classes. The dictionary contains the name, a short description and a dictionary with the default paremeter's values.

Run the calculation
~~~~~~~~~~~~~~~~~~~

::

    dwc.auto_flag_compute()
    
Flagging matrices are written in the data structure.

Selecting algorithm's parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Non default parameters can be selected either by passing a proper dictionary at the initialization

::

    dwc.auto_flag_init(i_dataset, alg, **param_dict)
    
or by calling 

::

    dwc.auto_flag_upd_params(**param_dict)
    
Available parameters are algorithm dependent. 
Since currently implemented algorithm are for test purpouse, more detailed information about the algorithm's parameters can be found in the developer's documentation.

Selectiong algorithm's output
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each RFI detection algorithm can return more than one flagging matrix.

Available output matrices can be checked without

::

    dwc.auto_flag_get_out()
    
The method returns a tuple containing a list with the available option and a dictionary with the current selection.

Output matrices can be selected when invoking the algorithm's computation

::

    dwc.auto_flag_compute(out_list)
    
    
*out_list* is a list of labels name for the selected output matrices

Since currently implemented algorithm are for test purpouse, more detailed information about the output matrices can be found in the developer's documentation.

